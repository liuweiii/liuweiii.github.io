---
layout: post
title:  "深入java虚拟机-2 JVM"
date:   2016-07-09 10:33:20 +0800
categories: java
tags:
- learn
- java
---

[https://docs.oracle.com/javase/specs/jvms/se7/html/index.html](https://docs.oracle.com/javase/specs/jvms/se7/html/index.html)

当说道“Java虚拟机”时，可能指的是如下三种不同的东西：

- 抽象规范
- 一个具体的实现
- 一个运行中的虚拟机实例

每个Java程序都运行于“一个运行中的虚拟机实例”上，该虚拟机实例是“抽象规范”的“一个具体的实现”。

## 1 Java虚拟机的生命周期

当启动一个Java程序时，一个虚拟机实例就诞生了。

当该程序关闭退出，这个虚拟机实例也随之消亡。

## 2 Java虚拟机的体系结构

![inside-jvm-2](/public/img/2016-07-09-inside-jvm2.gif)

 一个线程创建时，会分配一个**PC寄存器**和一个**Java栈**

**Java栈**由许多**栈桢**组成，一个栈桢包含一个Java方法调用的状态。当线程调用一个Java方法时，虚拟机压入一个新的栈桢到该线程的Java栈中；当该方法返回时，这个栈桢被从Java栈中弹出并抛弃。

### 2.1 Java虚拟机中的数据类型

![inside-jvm-2](/public/img/2016-07-09-inside-jvm3.gif)

编译器把Java源码编译为字节码时，会用int或byte来表示boolean；

和Java语言一样，Java虚拟机的基本类型的值域在任何平台都是一致的，如long始终是64位二进制补码表示的有符号整数；

returnAddress这个类型，Java程序员不能使用，它被用于实现Java程序中的finally子句；

### 2.2 类装载器子系统

Java虚拟机有两种类装载器：启动类装载器（Java虚拟机实现的一部分）和用户自定义类装载器（Java程序的一部分）。

负责查找并装载类型。

- 定位和导入二进制class文件
- 验证被导入类的正确性
- 为变量分配并初始化内存
- 帮助解析符号引用。

执行顺序：

1. 装载： 查找并装载类型的二进制数据
2. 连接： 执行验证、准备和解析（可选）
      - 验证： 确保被导入类型的正确性
      - 准备： 为类变量分配内存，并将其初始化为默认值
      - 解析： 把类型中的符号引用转化为直接引用
3. 初始化： 把类变量初始化为正确初始值

### 2.3 方法区

可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小

**内存中逻辑上存储被装载类型的信息的地方**


**所有线程都共享方法区，因此虚拟机对方法区数据的设计必须被设计为线程安全的**。比如，假设同时有两个线程都企图访问一个名为Lava的类，而这个类还没被装入虚拟机，那么，这时应该只有一个线程去装载它，而另一个线程只能等待。

**方法区的大小不必固定的也不必连续的，虚拟机可以根据应用的需要动态调整**，方法区可以在一个堆中自由分配。虚拟机也可以允许用户或者程序员制定方法区的初始大小及最大最小尺寸等。

**方法区*也可以*被垃圾收集**，因为虚拟机允许通过用户定义的类装载器来动态扩展Java程序，因此一些类也会成为程序“不再被引用”的类。当某个类变为不再被引用的类时，Java虚拟机可以卸载这个类（垃圾收集）。

1. **类型信息**
  - 类型的全限定名
  - 类型的直接超类的全限定名（除非这个类型是java.lang.Objcet，它没有超类）
  - 类型是类类型还是接口类型
  - 类型的访问修饰符（public、abstract或final的某个子集）
  - 任何直接超接口的全限定名的有序列表
2. 该类型的**常量池**
   *final*

   常量池就是该类型所用常量的一个有序集合，包括直接常量（string、integer和floating point常量）和对其他类型、字段和方法的符号引用。池中的数据项就像数组一样是通过索引访问的。常量池存储了相应类型所用到的所有类型、字段和方法的符号引用。

   当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。
3. **字段信息**
   - 字段名
   - 字段类型
   - 字段修饰符（public、private、protected、static、final、volatile、transient的某个子集）
   - 字段声明顺序
4. **方法信息**
   - 方法名
   - 方法的返回类型（或void）
   - 方法参数的数量和类型（按声明顺序）
   - 方法的修饰符（public、private、protected、static、final、synchronized、native、abstract的某个子集）
   - 方法声明顺序
   
5. **除了常量外的所有类（静态）变量**
   *static*
6. **一个到类ClassLoader的引用**

   每个类型被装载的时候，虚拟机必须跟踪它是由启动类装载器还是用户自定义类装载器装载的。如果是用户自定义类装载器装载的，虚拟机必须在类型信息中存储对该装载器的引用。虚拟机会在动态连接期间使用这个信息。
7. **一个到类Class的引用**
   
   对于每个被装载的类型（不管是类还是接口），虚拟机都会相应地为它创建一个java.lang.Class类的实例，而且虚拟机还必须以某种方式把这个实例和存储在方法区中的类型数据关联起来。Class类中的一个静态方法（public static Class forName(String className)）可以让用户得到任何已装载的类的Class实例的引用；或通过调用对象引用的getClass(public final Class getClass())方法,来得到这个对象的类的Class对象引用。
8. **方法表**

   为了尽可能提高访问效率，虚拟机的实现中可能还包括方法表。虚拟机对每个装载的非抽象类，都生成一个方法表，把它作为类信息的一部分保存在方法区。方法表是一个数组，它的元素是所有它的实例可能被调用的实例方法的直接引用，包括那些从超类继承过来的实例方法。（对于抽象类和接口，方法表没有什么帮助，因为程序决不会生成它们的实例。）

*java.lang.Objcet和接口都没有超类*

### 2.4 堆

通过-Xms(最小值)和-Xmx(最大值)参数设置

Java程序在运行时创建的所有类实例或数组都放在同一个堆中，而一个Java虚拟机实例中只存在一个堆空间，因此所有线程都将共享这个堆。又由于一个Java程序独占一个Java虚拟机实例，因此每个Java程序都有它自己的堆空间，它们彼此不会干扰。但同一个Java程序的多个线程却共享着同一个堆空间。

**垃圾收集** 回收不再引用的对象所占的内存，也可能去移动还在使用的对象，以此减少堆碎片。

**JVM规范并没要求实现垃圾收集**，只是要求虚拟机实现必须“以某种方式”管理自己的堆空间，规范仅仅告诉实现JVM的设计者，Java程序需要从堆中为对象分配空间，并且程序本身不会主动释放它，因此堆空间的管理（包括垃圾收集）问题得由设计者自行考虑处理方式。

**堆空间不必是连续的内存区，在程序运行时可以动态扩展或收缩**。

1. **对象的内部表示：**

  - 在对象中通常会有一个**指向方法区的类型信息的指针**，以便虚拟机能够通过对象引用得到类（类型）数据。

  - 在内存充足的系统中，对象可以有**方法表**（类似与c++的vtbl虚拟表），方法表一般位于方法区。

  - 对上的每个对象数据中还有一个逻辑部分——**对象锁**，它被用于协调多个线程访问同一个对象时的同步。任何时刻，只能有一个线程“拥有”这个对象锁，因此只有这个线程才能访问该对象的数据，此时其他希望访问这个对象的线程只能等待。很多对象在其整个生命周期内都没有被任何线程加锁，在线程实际请求某个对象的锁之前，实现对象锁所需要的数据是不必要的。很多实现不在对象自身内部保存一个指向锁数据的指针，而只有当第一次需要加锁的时候才分配对应的锁数据，但这时虚拟机需要用某种间接方法来联系对象数据和对应的锁数据，例如把锁数据放在一个以对象地址为索引的搜索树中。

  - **等待集合** 用来让多个线程完成一个共同目标而协调工作的。由等待方法和通知方法联合使用。每个类都从Objcet那里继承了3个等待方法（三个名为wait()的重载方法)和两个通知方法（notify()及notifyAll()）。当某个线程在一个对象上调用等待方法时，虚拟机就阻塞这个线程，并把它放在了这个对象的等待集合中。直到另一个线程在同一个对象上调用通知方法，虚拟机才会在之后的某个时刻唤醒一个或多个在等待集合中被阻塞的线程。像锁数据一样，在实际调用对象的等待方法或通知方法之前，实现对象的等待集合的数据并不是必须的，因此许多虚拟机实现都把等待集合数据与实际对象数据分开，只有在需要时才为此对象创建同步数据（通常是在第一次调用等待方法或通知方法时）。

  - **与垃圾收集器有关的数据**，垃圾收集器必须（以某种方式）跟踪程序引用的每个对象，这个任务不可避免地要附加一些数据给这些对象，数据的类型要视垃圾收集算法而定。像线程锁一样，这些数据也可以房子对象数据外。
2. **数组的内部表示：**

  - **指向方法区的类型信息的指针**，和其他所有对象一样，数组也拥有一个与它们的类相关联的Class实例，所有具有相同维度和类型的数组都是同一个类的实例，而不管数组的长度（多维数组每一维的长度）是多少。例如一个包含3个int的数组和一个包含300个int的数组拥有同一个类。

### 2.5 程序计数器（PC register）
对于一个运行中的Java程序而言，每个线程都有它自己的PC寄存器，它是在该线程启动时创建的。PC寄存器的大小是一个字长，因此它既能够持有一个本地指针，也能够持有一个returnAddress。当线程执行某个Java方法时，PC寄存器的内容总是下一条将被执行指令的“地址”（这个地址可以是一个本地指针，也可以是在方法字节码中相对于该方法起始指令的偏移量）。如果该线程正则执行一个本地方法，那么此时PC寄存器的值是“undefined”。