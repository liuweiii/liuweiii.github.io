---
layout: post
title:  "深入java虚拟机-2 JVM"
date:   2016-07-09 10:33:20 +0800
categories: java
tags:
- learn
- java
---

[https://docs.oracle.com/javase/specs/jvms/se7/html/index.html](https://docs.oracle.com/javase/specs/jvms/se7/html/index.html)

当说道“Java虚拟机”时，可能指的是如下三种不同的东西：

- 抽象规范
- 一个具体的实现
- 一个运行中的虚拟机实例

每个Java程序都运行于“一个运行中的虚拟机实例”上，该虚拟机实例是“抽象规范”的“一个具体的实现”。

## 1 Java虚拟机的生命周期

当启动一个Java程序时，一个虚拟机实例就诞生了。

当该程序关闭退出，这个虚拟机实例也随之消亡。

## 2 Java虚拟机的体系结构

![inside-jvm-2](/public/img/2016-07-09-inside-jvm2.gif)

 一个线程创建时，会分配一个**PC寄存器**和一个**Java栈**

**Java栈**由许多**栈帧**组成，一个栈帧包含一个Java方法调用的状态。当线程调用一个Java方法时，虚拟机压入一个新的栈帧到该线程的Java栈中；当该方法返回时，这个栈帧被从Java栈中弹出并抛弃。

### 2.1 Java虚拟机中的数据类型

![inside-jvm-2](/public/img/2016-07-09-inside-jvm3.gif)

编译器把Java源码编译为字节码时，会用int或byte来表示boolean；

和Java语言一样，Java虚拟机的基本类型的值域在任何平台都是一致的，如long始终是64位二进制补码表示的有符号整数；

returnAddress这个类型，Java程序员不能使用，它被用于实现Java程序中的finally子句；

### 2.2 类装载器子系统

Java虚拟机有两种类装载器：启动类装载器（Java虚拟机实现的一部分）和用户自定义类装载器（Java程序的一部分）。

负责查找并装载类型。

- 定位和导入二进制class文件
- 验证被导入类的正确性
- 为变量分配并初始化内存
- 帮助解析符号引用。

执行顺序：

1. 装载： 查找并装载类型的二进制数据
2. 连接： 执行验证、准备和解析（可选）
      - 验证： 确保被导入类型的正确性
      - 准备： 为类变量分配内存，并将其初始化为默认值
      - 解析： 把类型中的符号引用转化为直接引用
3. 初始化： 把类变量初始化为正确初始值

### 2.3 运行时数据区

![inside-jvm-2](/public/img/2016-07-10-inside-jvm3.png)

#### 2.3.1 方法区

可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小

**内存中逻辑上存储被装载类型的信息的地方**


**所有线程都共享方法区，因此虚拟机对方法区数据的设计必须被设计为线程安全的**。比如，假设同时有两个线程都企图访问一个名为Lava的类，而这个类还没被装入虚拟机，那么，这时应该只有一个线程去装载它，而另一个线程只能等待。

**方法区的大小不必固定的也不必连续的，虚拟机可以根据应用的需要动态调整**，方法区可以在一个堆中自由分配。虚拟机也可以允许用户或者程序员制定方法区的初始大小及最大最小尺寸等。

**方法区*也可以*被垃圾收集**，因为虚拟机允许通过用户定义的类装载器来动态扩展Java程序，因此一些类也会成为程序“不再被引用”的类。当某个类变为不再被引用的类时，Java虚拟机可以卸载这个类（垃圾收集）。

1. **类型信息**
  - 类型的全限定名
  - 类型的直接超类的全限定名（除非这个类型是java.lang.Objcet，它没有超类）
  - 类型是类类型还是接口类型
  - 类型的访问修饰符（public、abstract或final的某个子集）
  - 任何直接超接口的全限定名的有序列表
2. 该类型的**常量池**
   *final*

   常量池就是该类型所用常量的一个有序集合，包括直接常量（string、integer和floating point常量）和对其他类型、字段和方法的符号引用。池中的数据项就像数组一样是通过索引访问的。常量池存储了相应类型所用到的所有类型、字段和方法的符号引用。

   当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。
3. **字段信息**
   - 字段名
   - 字段类型
   - 字段修饰符（public、private、protected、static、final、volatile、transient的某个子集）
   - 字段声明顺序
4. **方法信息**
   - 方法名
   - 方法的返回类型（或void）
   - 方法参数的数量和类型（按声明顺序）
   - 方法的修饰符（public、private、protected、static、final、synchronized、native、abstract的某个子集）
   - 方法声明顺序
   
5. **除了常量外的所有类（静态）变量**
   *static*
6. **一个到类ClassLoader的引用**

   每个类型被装载的时候，虚拟机必须跟踪它是由启动类装载器还是用户自定义类装载器装载的。如果是用户自定义类装载器装载的，虚拟机必须在类型信息中存储对该装载器的引用。虚拟机会在动态连接期间使用这个信息。
7. **一个到类Class的引用**
   
   对于每个被装载的类型（不管是类还是接口），虚拟机都会相应地为它创建一个java.lang.Class类的实例，而且虚拟机还必须以某种方式把这个实例和存储在方法区中的类型数据关联起来。Class类中的一个静态方法（public static Class forName(String className)）可以让用户得到任何已装载的类的Class实例的引用；或通过调用对象引用的getClass(public final Class getClass())方法,来得到这个对象的类的Class对象引用。
8. **方法表**

   为了尽可能提高访问效率，虚拟机的实现中可能还包括方法表。虚拟机对每个装载的非抽象类，都生成一个方法表，把它作为类信息的一部分保存在方法区。方法表是一个数组，它的元素是所有它的实例可能被调用的实例方法的直接引用，包括那些从超类继承过来的实例方法。（对于抽象类和接口，方法表没有什么帮助，因为程序决不会生成它们的实例。）

*java.lang.Objcet和接口都没有超类*

#### 2.3.2 堆

通过-Xms(最小值)和-Xmx(最大值)参数设置

Java程序在运行时创建的所有类实例或数组都放在同一个堆中，而一个Java虚拟机实例中只存在一个堆空间，因此所有线程都将共享这个堆。又由于一个Java程序独占一个Java虚拟机实例，因此每个Java程序都有它自己的堆空间，它们彼此不会干扰。但同一个Java程序的多个线程却共享着同一个堆空间。

**垃圾收集** 回收不再引用的对象所占的内存，也可能去移动还在使用的对象，以此减少堆碎片。

**JVM规范并没要求实现垃圾收集**，只是要求虚拟机实现必须“以某种方式”管理自己的堆空间，规范仅仅告诉实现JVM的设计者，Java程序需要从堆中为对象分配空间，并且程序本身不会主动释放它，因此堆空间的管理（包括垃圾收集）问题得由设计者自行考虑处理方式。

**堆空间不必是连续的内存区，在程序运行时可以动态扩展或收缩**。

1. **对象的内部表示：**

  - 在对象中通常会有一个**指向方法区的类型信息的指针**，以便虚拟机能够通过对象引用得到类（类型）数据。

  - 在内存充足的系统中，对象可以有**方法表**（类似与c++的vtbl虚拟表），方法表一般位于方法区。

  - 对上的每个对象数据中还有一个逻辑部分——**对象锁**，它被用于协调多个线程访问同一个对象时的同步。任何时刻，只能有一个线程“拥有”这个对象锁，因此只有这个线程才能访问该对象的数据，此时其他希望访问这个对象的线程只能等待。很多对象在其整个生命周期内都没有被任何线程加锁，在线程实际请求某个对象的锁之前，实现对象锁所需要的数据是不必要的。很多实现不在对象自身内部保存一个指向锁数据的指针，而只有当第一次需要加锁的时候才分配对应的锁数据，但这时虚拟机需要用某种间接方法来联系对象数据和对应的锁数据，例如把锁数据放在一个以对象地址为索引的搜索树中。

  - **等待集合** 用来让多个线程完成一个共同目标而协调工作的。由等待方法和通知方法联合使用。每个类都从Objcet那里继承了3个等待方法（三个名为wait()的重载方法)和两个通知方法（notify()及notifyAll()）。当某个线程在一个对象上调用等待方法时，虚拟机就阻塞这个线程，并把它放在了这个对象的等待集合中。直到另一个线程在同一个对象上调用通知方法，虚拟机才会在之后的某个时刻唤醒一个或多个在等待集合中被阻塞的线程。像锁数据一样，在实际调用对象的等待方法或通知方法之前，实现对象的等待集合的数据并不是必须的，因此许多虚拟机实现都把等待集合数据与实际对象数据分开，只有在需要时才为此对象创建同步数据（通常是在第一次调用等待方法或通知方法时）。

  - **与垃圾收集器有关的数据**，垃圾收集器必须（以某种方式）跟踪程序引用的每个对象，这个任务不可避免地要附加一些数据给这些对象，数据的类型要视垃圾收集算法而定。像线程锁一样，这些数据也可以房子对象数据外。
2. **数组的内部表示：**

  - **指向方法区的类型信息的指针**，和其他所有对象一样，数组也拥有一个与它们的类相关联的Class实例，所有具有相同维度和类型的数组都是同一个类的实例，而不管数组的长度（多维数组每一维的长度）是多少。例如一个包含3个int的数组和一个包含300个int的数组拥有同一个类。

#### 2.3.3 程序计数器（PC register）
对于一个运行中的Java程序而言，每个线程都有它自己的PC寄存器，它是在该线程启动时创建的。PC寄存器的大小是一个字长，因此它既能够持有一个本地指针，也能够持有一个returnAddress。当线程执行某个Java方法时，PC寄存器的内容总是下一条将被执行指令的“地址”（这个地址可以是一个本地指针，也可以是在方法字节码中相对于该方法起始指令的偏移量）。如果该线程正则执行一个本地方法，那么此时PC寄存器的值是“undefined”。

#### 2.3.4 Java栈

每当启动一个新线程时，Java虚拟机都会为它分配一个Java栈。Java栈由**栈帧（frame）**（或称为**帧**）组成，虚拟机只会直接对Java栈执行两种操作：以帧为单位的压栈或出栈。

某个线程正则执行的方法被称为该线程的**当前方法**，当前方法使用的栈帧成为**当前帧**，当前方法所属的类称为**当前类**，当前类的常量池称为**当前常量池**。

每当线程调用一个Java方法时，虚拟机都会在该线程的Java栈中压入一个新帧。这个新帧就成为了当前帧。在执行这个方法时，使用这个帧来存储参数、局部变量、中间运算结果等数据。

Java栈和帧在内存中不必是连续的。

**栈帧**

1. **局部变量区**
   - 是一个以字长为单位的数组，通过索引来访问。int、float、reference、returnAddress、byte、short、char占据一项，long和double占据连续的两项。
   - 包含**对应方法的参数**和**局部变量**。
   - 如果是非static的方法，**对应方法的参数**还包含一个表示调用该方法的对象本身的reference（引用）类型参数。
   - 在Java中，所有对象都按引用传递，并且都存储在堆中，永远不会在局部变量区或操作数栈中发现对象的拷贝，只会有对象引用。
2. **操作数栈**
   - 是一个以字长为单位的数组，通过标准的栈操作（出栈和压栈）来访问的。比如某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。
   - 虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的。
   - Java虚拟机的指令是从操作数栈中取得操作数的。
   - 虚拟机把操作数栈作为它的工作区——大多是指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。
3. **帧数据区**
   Java栈帧需要一些数据来支持常量池解析、正常方法返回以及异常派发机制。
   - 用于常量池解析：从常量池取出数据压入java栈；用常量池的数据来指示要实例化的类或数组、要访问的字段或要调用的方法；用常量池中的数据来确定某个对象是否属于某个类或实现了某个接口。
   - 用于处理java方法的正常结束或异常中止：如果是通过return正常结束，虚拟机必须回复发起调用的方法的栈帧，包括设置PC寄存器指向发起调用的方法中的指令（即紧跟着调用了完成方法的指令的下一个指令）。加入方法有返回值，还需将它压入发起调用的方法的操作数栈。
   - 用于处理异常退出的情况：帧数据区还必须保存一个对此方法异常表的引用。当某个方法抛出异常时，虚拟机根据帧数据区对应的异常表来决定如何处理。如果在异常表中找到了匹配的catch子句，就会把控制权转交给catch子句内的代码，如果没有发现，方法会立即异常中止，然后使用帧数据区的信息恢复发起调用的方法的帧，在发起调用的方法的上下文中重新抛出同样的异常。
   - 调试的数据信息。

#### 2.3.5 本地方法栈
本地方法栈依赖于虚拟机的实现（HotSpot JVM中Java虚拟机栈和本地方法栈被实现为同一个栈区），当线程调用一个本地方法时，就进入了一个权限的并且不再受虚拟机限制的世界，可以做任何事情。

当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入java栈；当调用本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用制定的本地方法。可以把这看作是虚拟机利用本地方法来动态扩展自己。













