---
layout: post
title:  "深入java虚拟机"
date:   2016-07-09 10:33:20 +0800
categories: java
tags:
- learn
- java
---

## 1 Java体系结构

**Java体系结构的四个相关技术**

- Java程序设计语言
- Java class 文件格式
- Java应用编程接口（API）
- Java虚拟机
- 
**Java面向网络体系结构的三大支柱**

- 平台无关性
- 安全性
- 网络移动性

### 1.1 Java虚拟机

#### 1.1.1 主要任务：

装载class文件并执行其中的字节码

#### 1.1.2 支持Java面向网络体系结构三大支柱的：

- 平台无关性
- 安全性（类装载器）
- 网络移动性（类装载器）

### 1.2 Java class文件

#### 1.2.1 支持Java面向网络体系结构三大支柱的：

**平台无关性**：为Java程序提供独立于底层主机平台的二进制形式的服务；

**网络移动性**：class文件设计得紧凑，class文件可以在需要的时候才下载。

### 1.3 Java API

#### 1.3.1 支持Java面向网络体系结构三大支柱的：

**平台无关性**：由于Java API class文件调用了本地方法，Java程序就不需要再调用它们了，通过这种方法，Java API class文件为底层主机提供了平台无关性的标准接口。

**安全性**：当Java API的方法进行任何有潜在危险的操作之前，都会通过查询安全管理器（Java 1.2后被访问控制器取代）来检验是否得到了授权。

### 1.4 Java程序设计语言

- 禁止直接访问内存
- 自动垃圾收集
- 数组边界检查
- 对象引用检查（空引用检查）

## 2 安全

**Java沙箱的基本组件**

- 类装载器结构（可用户定制）
- class文件检验器
- 内置于Java虚拟机（及语言）的安全特性
- 安全管理器（可用户定制）及Java API

### 2.1 类装载器

同一个特定命名空间下只能有一个特定的名字，不能重复；

**双亲委派模式** 类装载器请求另一个类装载器来装载类型的过程。

除启动类装载器外，每一个类装载器都有一个“双亲”类装载器；
在某个特定的类装载器在装载类型前，都会先让它的双亲来装载，如果它的“双亲”装载了，它就不需要自己再装载了；

**运行时包** 同一个类装载器装载的、属于同一个包的多个类型的集合。

同一个运行时包里的成员可以访问包中的类型和包内可见成员。
类装载器可以简单地拒绝装载特定的禁止类型或包。
类装载器必须将每一个被装载的类放置在一个保护域中，一个保护域定义了这个代码在运行时将得到怎样的权限。

- 启动类装载器：装载核心Java API的class文件
- 扩展类装载器：装载来自于任何已安装扩展的class文件
- 类路径装载器：装载类路径中发现的class文件

### 2.2 class文件检验器

#### 2.2.1 第一趟扫描：class文件的结构检查

检查举例：
检查魔数 cafebabe；
检查class文件中声明的版本号是否在本java虚拟机实现的支持范围内；
检查class的长度和内容是否一致。

#### 2.2.2 第二趟：类型数据的语义检查（检查了一些java语言应该在编译时遵守的强制规则）

检查举例：
检查方法描述符是符合特定语法、格式的字符串；
检查类是否都是Objcet的子类；
检查final类没有被子类化、final方法没有被覆盖。

#### 2.2.3 第三趟：字节码验证

**字节码**代表了Java的方法，它是由被称为操作码的单字节指令组成的序列，每一个操作码后都跟着一个或多个操作数

**栈桢（一个方法调用对应一个栈桢）**

字节码流：代表了java的方法，由操作码组成

执行字节码（依次执行操作码）使形成线程，每个线程有自己的栈，栈由**栈桢**构成

操作码后跟着一个或多个操作数

操作数栈：栈桢中用于存储方法的中间结果

An opcode and its (optional) operands may refer to the data stored on the operand stack or in the local variables of the methodís frame. 

操作码和它的（可选的）操作数 可能指向存储在 **操作数栈** 或 该方法所在栈桢中的局部变量 中的数据

![inside-jvm-2](/public/img/2016-07-09-inside-jvm.gif)

- 确保任何路径在字节码流中都得到一个确定的操作码
- 确保操作数栈总数包含正确的数值以及正确的类型
- 确保局部变量在赋值前不能被访问
- 确保类的字段赋予正确类型的值
- 确保方法调用时传递正确数值和类型的参数
- 确保每个操作码都是合法的（有合法的操作数，合适类型的数值位于局部变量或操作数栈中）

**字节码检验器不会试图检查出所有安全问题，因为这样会遇到“停机问题”的悖论**

**Java虚拟机装载了一个类，并对它进行了第一到第三趟的class文件检验，这些字节码就可以被运行了。**

#### 2.2.4 第四趟：符号引用的验证

这趟可以在字节码执行时才进行；
这趟是动态连接过程的一部分；
这趟扫描要检查被检测的class文件以外的其他类，所以可能需要装载新的类。
当Java虚拟机执行字节码时，如果遇到一个操作码，这个操作码第一次使用一个指向另一个类的符号引用，那么虚拟机就必须解析这个符号引用。在解析时，虚拟机执行两个基本任务：

- 查找被引用的类（如果必要的话就装载它）
- 将符号引用替换为直接引用，例如一个指向类、字段或方法的指针或偏移量

### 2.3 Java虚拟机中内置的安全特性

- 类型安全的引用转化
- 结构化的内存访问（无指针算法）
- 自动垃圾收集（不必显式释放被分配的内存）
- 数组边界检查
- 空引用检查