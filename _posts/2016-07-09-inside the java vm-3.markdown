---
layout: post
title:  "深入java虚拟机-3 类型的生命周期"
date:   2016-07-11 22:03:20 +0800
categories: java
tags:
- learn
- java
---

## 1 类型装载、连接与初始化

![inside-jvm-3](/public/img/2016-07-11-inside-jvm3.png)

### 1.1 装载

装载的最终产品就是一个java.lang.Class类的实例对象。

1. 加载类型二进制数据
   - 从本地文件系统装载一个Java class文件
   - 通过网络下载一个Java class文件
   - 从一个ZIP、JAR、CAB或者其他某种归档文件中提取Java class文件
   - 从一个i额专有数据库中提取Java class文件
   - 把一个i额Java源文件动态编译为class文件格式
   - 动态为某个类型计算其class文件数据
   - 使用上述任何方法，但是使用不同于Java class文件的其他二进制文件格式
2. 创建类型
   把一个类型的二进制数据解析为方法区中的内部数据结构
3. 在堆上建立一个Class对象

如果一个类装载器在预先装载时遇到缺失或者错误的class文件，它必须等到程序首次主动使用该类时才报告错误（LinkageError异常）。

### 1.2 验证

确认类型符合Java语言的语义，并且它不会危及虚拟机的完整性。

- 检查final的类不能拥有之类
- 检查final的方法不能被覆盖
- 确保在类型和超类型直接没有不兼容的方法声明（比如两个方法拥有同样的名字，参数在数量、顺序、类型上都相同，但返回类型不同）
- 检查常量池入口相互之间一致
- 检查常量池中的所有特殊字符串是否符合格式
- 检查字节码的完整性

虚拟机的实现可以选择一些进行验证

### 1.3 准备

虚拟机为类变量分配内存，并设置默认初始值，但在到达初始化阶段之前，类变量都没有被初始化为真正的初始值。Java虚拟机实现可能也为一些数据结构分配内存，如方法表，它包含指向类中每一个方法（包括从超类继承的方法）的指针，方法表可以使得继承的方法执行时不需要搜索超类。

### 1.4 解析

解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程。

### 1.5 初始化

为了准备让一个类或者接口被首次主动使用，最后一个步骤就是初始化，也就是为类变量赋予正确的初始值。这里的“正确”初始值指的是程序员希望这个类变量所具备的起始值。

一个正确的初始值是通过**类变量初始化语句**或者**静态初始化语句**给出的。
**类变量的初始化语句**：static int size = 3
**静态初始化语句**： static int size; static｛ size = 3; ｝

初始化一个类包含两个步骤：
 1. 如果类存在直接超类，而直接超类还没有被初始化，就先初始化直接超类；
 2. 如果类存在一个类初始化方法，就执行此方法

## 2 对象的生命周期

### 2.1 类实例化

实例化一个类有四种途径：
1. 使用new操作符
2. 调用Class或者java.lang.reflect.Constructor对象的newInstance方法；
3. 调用任何现有对象的clone方法
4. 通过java.io.ObjectInputStream类的getObject方法反序列化

### 2.2 垃圾收集和对象的终结
程序可以明确或者隐含地为对象分配内存，但不能明确地释放内存。一旦对象不再为程序引用了，虚拟机必须回收（GC）那部分内存。

如果类声明了一个名为finalize()的返回void的方法，垃圾收集器会在释放这个实例所占据的内存空间之前执行这个方法一次。

{% highlight java linenos %}
class XX｛
  protected void finalize(){
    System.out.println("A Finale object was finallized.");
  }
｝
{% endhighlight %}

垃圾收集器（最多）只会调用一个对象的终结方法一次。如果终结方法代码执行后，对象被重新引用（复活）了，随后再次变得不被引用，垃圾收集器不会第二次调用终结方法。垃圾收集器自动调用的finalize方法抛出的任何异常都将被忽略。

## 3 卸载类型

在很多方面，Java虚拟机中类的声明周期和对象的声明周期很相似。虚拟机创建并初始化对象，使程序能使用对象，然后在对象变得不再被引用后可选地执行垃圾收集。同样，虚拟机装载、连接并初始化类，使程序能使用类，当程序不再引用它们的时候可选地卸载它们。

类的垃圾收集和卸载之所以在Java虚拟机中很重要，是因为Java程序可以在运行时通过用户自定义的类装载器装载类型来动态地扩展程序，所有被装载的类型都在方法区占据内存空间。如果Java程序持续通过用户自定义类装载器装载类型，方法区的内存足迹就会不断增长。如果某些动态装载的类型只是临时需要，当它们不再被引用之后，占据的内存空间可以通过卸载类型而释放。

如果程序不再引用某类型，那么这个类型就无法对未来的计算过程产生影响，类型变成不可触及的，那么这个类型就可以被垃圾收集。

使用启动类装载器装载的类型永远是可触及的，所以永远不会被卸载。只有用户自定义类装载器装载的类型才可能被虚拟机回收。