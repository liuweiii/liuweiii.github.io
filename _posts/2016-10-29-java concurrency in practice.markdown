---
layout: post
title:  "java concurrency in practice"
date:   2016-10-29 21:20:00 +0800
categories: java
tags:
- jsr 166
- learn
- java
---

## 1.线程安全性##

### 1.1.线程安全性### 

当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

*当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替运行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。*

无状态对象一定是线程安全的。

### 1.2.原子性###

i++和++i都不是原子操作，实际上包含了3个独立操作：读取值，将值加1，将结果写入。

#### 1.2.1.竞态条件####

在并发编程中，由于不恰当的执行时序而出现不正确的结果，就成为竞态条件。

当某个计算的正确性取决于多个线程交替执行时序时，就会发生竞态条件，换句话说，就是正确的结果要取决于运气。最常见的竞态条件类型就是“先检查后执行”操作，即通过一个可能失效的观测结果来决定下一步的动作。

*假定两个操作A和B，如果从执行A的线程来看，另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说就是原子的。*

#### 1.2.2.复合操作####

将“先检查后执行”和“读取-修改-写入”等操作称为复合操作：包含了一组必须以原子方式执行的操作以确保线程安全性。

### 1.3.加锁机制###

*要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量*

#### 1.3.1.内置锁####

{% highlight java linenos %}
synchronized (lock){
  //
}
{% endhighlight %}

Java的内置锁相当于一种互斥锁，意味着最多只有一个线程能持有这种锁。

#### 1.3.2.重入####

当某个线程试图获得一个已经由自己持有的锁，这个请求会成功。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。

### 1.4. 用锁来保护状态###

*对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。*

当获取与对象关联的锁时，并不能阻止其他线程访问该对象，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，只是为了免去显式地创建锁对象。

一种常见的加锁约定是，将所有可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。

并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。

*对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护*。

### 1.5.活跃性与性能###

*在简单性与性能之间存在着相互制约因素，当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（可能会破坏安全性）。*

*当执行时间较长的计算或者可能无法快速完成的操作时（如网络I/O或控制台I/O），一定不要持有锁。*

## 2.对象的共享##

### 2.1.可见性###

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程都必须在同一个锁上同步。

加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

### 2.2.发布与逸出###

**发布**： 讲一个指向该对象的引用保存到其他代码可以访问的地方，或者在某个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。

**逸出**：发布某个不应该发布的对象时，称为逸出。

很多情况下，要确保对象及其内部状态不被发布；而某些情况下，又需要发布某个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，使得程序难以维持不变性条件。例如，在对象构造完成之前就发布该对象，会破坏线程安全性。

发布的几种方式：

1. 将对象引用保存到一个公有静态变量中，以便任何类和线程都能看见该对象。

2. 从非私有方法中返回一个引用，同样会发布返回的对象。

3.  发布一个内部的类实例

*不要在构造过程中使this引用逸出。*

在构造过程中使this引用逸出的一个常见错误是，在构造函数中启动一个线程。在对象的构造函数中创建一个线程时，this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。在构造函数中创建线程并没有错，但最好不要立即启动它，而是通过一个start或initialize方法来启动。

{% highlight java linenos %}
public class Test {

    private boolean isIt;

    public Test() throws InterruptedException {
        new Thread(new Runnable() {
            public void run() {
                System.out.println(isIt);
            }
        }).start();
        Thread.sleep(2000L);
        isIt = true;
    }

    public static void main(String[] args) throws InterruptedException {
        Test test = new Test();
    }
}
{% endhighlight %}
打印的结果是false，这个例子就是隐式的this对象引用逸出，还没有实例化完成时，其他线程就已经要用到对象中的属性

*stackoverflow上的一个例子(如果有多个实例在多个线程中被初始化，某些线程用的this可能是未被完全初始化的)：*
{% highlight java linenos %}
public class Test
{
    private static Test lastCreatedInstance;

    public Test()
    {
        lastCreatedInstance = this;
    }
}
{% endhighlight%}

书（《Java并发编程实战》）上的会this逸出例子是：
{% highlight java linenos %}
public class ThisEscape {
  public ThisEscape(EventSource source) {
    source.registerListener(new EventListener() {
      public void onEvent(Event e) {
        doSomething(e);
      }
    });
}
{% endhighlight %}
给出的正解是：
{% highlight java linenos %}
public class SafeListener {
  private final EventListener listener;

  private SafeListener() {
    listener = new EventListener() {
      public void onEvent(Event e) {
        doSomething(e);
      }
    };
  }

  public static SafeListener newInstance(EventSource source) {
    SafeListener safe = new SafeListener();
    source.registerListener(safe.listener);
    return safe;
  }
}
{% endhighlight %}
当构造好了SafeListener对象之后，我们才启动了监听线程，也就确保了SafeListener对象是构造完成之后在使用的SafeListener对象。

### 2.3. 线程封闭###

即对象只能由单个线程访问。

当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性。

线程封闭的几种方法：
**1. Ad-hoc线程封闭** ？？？ 维护线程封闭性的职责完全由程序实现来承担，Ad-hoc线程封闭性是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。、

**2. 栈封闭**  只能通过局部变量访问对象。

**3. ThreadLocal类**  维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程调用set时设置的最新值。

ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量的传递复杂度。

提供线程内部的局部变量，在本现场内随时随地可取，隔离其他线程。


### 2.4. 不变性###

*不可变对象一定是线程安全的。*

final类型的域是不能修改的（但如果final域所引用的对象是可变的，这些被引用的对象是可以修改的。另，通过反射可以修改final域），此外，final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

*正如“除非需要更高的可见性，否则应将所有域声明为私有域“是一个良好的编程习惯，”除非需要某个域是可变的，否则应将其声明为final域“，也是一个良好的编程习惯。*

### 2.5. 安全发布###

不正确的发布导致正确的对象被破坏。

#### 2.5.1. 不可变对象与初始化安全性####

即使在发布不可变对象引用时没有使用同步，也仍然可以安全地访问该对象。为了维持这种初始化安全性的保证，必须满足不可变性的所有需求：状态不可修改，所有域都是final类型，以及正确的构造过程。

#### 2.5.2. 安全发布的常用模式####

要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：

- 在静态初始化函数中初始化一个对象引用。

- 将对象的引用保存到volatile类型的域或者AtomicReferance对象中。

- 将对象的引用保存到某个正确构造对象的final类型域中。

- 将对象的引用保存到一个由锁保护的域中。

线程A将对象X放入一个线程安全的容器，随后线程B读取这个对象，那么可以确保B看到A设置的X状态，即便在这段读/写X的应用程序代码中没有包含显示的同步。

通常，要发布一个静态构造的对象，最简单和最安全的方式是使用静态初始化器：

{% highlight java linenos %}
public static Holder holder = new Holder(42);
{% endhighlight %}

静态初始化器由JVM在类初始化阶段执行。由于在JVM内部存在者同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。

#### 2.5.3. 事实不可变对象####

如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象”。

#### 2.5.4. 可变对象####

对象的发布需求取决于它的可变性：

- 不可变对象可以通过任意机制来发布。

- 事实不可变对象必须通过安全方式来发布。

- 可变对象必须通过安全方式来发布，而且必须是线程安全的或者由某个锁保护起来。

#### 2.5.5. 安全地共享对象####

在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：

**线程封闭**线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。

**只读共享**在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。

**线程安全共享**线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来访问而不需要进一步的同步。

**保护对象**被包含的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

## 3. 对象的组合##

### 3.1. 设计线程安全的类###

在设计线程安全类的过程中，需要包含一下三个基本要素：

- 找出构成对象状态的所有变量。

- 找出约束状态变量的不变性条件。

- 建立对象状态的并发访问管理策略。

许多情况下，所有权与封装性总是相互关联的：对象封装它拥有的状态，反之也成立，即对它封装的状态拥有所有权。然而，如果发布了某个可变对象的引用，那么就不再拥有独占的控制权，最多是“共享控制权”。

对于从构造函数或从方法中传递进来的对象，类通常并不拥有这些对象，除非这些方法是被专门设计为转移传递进来的对象的所有权（如，同步容器封装器的工厂方法）。

容器类通常表现出一种“所有权分离”的形式，其中容器类拥有其自身的状态，而客户代码则拥有容器中各个对象的状态。

### 3.2. 实例封闭###

将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

*封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。*

遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。许多类中都使用了Java监视器模式，如Vector和Hashtable。

Java监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态。

**使用私有锁来保护状态**
{% highlight java linenos %}
public class PrivateLock{
  private final Object myLock = new Object();
  Widget widget;
  void someMethod(){
    synchronized(myLock){
      // visit widget;
    }
  }
}
{% endhighlight %}

使用私有锁对象而不是对象的内置锁（或任何其他可通过公有方式访问的锁）。私有的锁对象可以将锁封装起来，使客户代码无法得到锁，客户代码可以通过公有方法访问锁。

在某些情况下，通过多个线程安全类组合而成的类是线程安全的，而在某些情况下，这仅仅是一个好的开端。

*【m】如果一个对象需要被多个线程安全地使用，

简单来做：首先不能让该对象的字段逸出（不要有非final的public字段，且如果是final的public字段也可能逸出，如public ArrayList<Object>，这个ArrayList的Object就是可变的；不要通过方法把非final字段的引用扔出去，扔出去的final字段对象中不要包含可变的字段），然后把对象的每个方法都synchronized。这样保证了线程安全，但是并发大的时候性能降低。

好的方法：不实用synchronized，但保证所有字段都是final的，且是安全发布的。*

*【m】类的多个状态各自都是线程安全的，但经过组合得到的这个类却不一定是线程安全的，因为这些状态间彼此可能不是独立的，这时可以通过加锁机制来维护不变性条件以确保其线程安全性。同时还得避免发布这些状态，防止客户代码破坏其不变性条件。*