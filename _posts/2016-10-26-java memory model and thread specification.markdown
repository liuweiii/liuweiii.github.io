---
layout: post
title:  "java memory model and thread specification"
date:   2016-10-26 06:21:20 +0800
categories: java
tags:
- jsr 133
- learn
- java
---

## 1.Introduction

只能通过Thread类创建线程对象。

同一个对象的多个synchronized执行体中如果有一个synchronized被进入，其他的也会被lock（相当于整个object被lock）。

不管synchronized的执行体是正常还是异常结束，都会自动unlock。

有多种机制可以用于线程间通信。其中最基础的是同步，同步是用管程(monitor)来实现的。每个对象都关联着一个管程，线程可以通过它来执行锁定（ lock） 或解锁（ unlock） 操作。每次仅有一个线程可以持有管程上的锁。其它试图锁定该管程的线程会一直阻塞，直到能从该管程上获得锁为止。

**数据争用（data race）**的条件

- 一个线程里有个写操作

- 另一个线程读取了这个写入的变量值

- 且读写操作没有被同步排序

理解一个程序是否被正确同步的两个概念：

1. **冲突访问（Conflicting Accesses）**：对同一个共享字段或数组元素存在两个访问（读或写），且至少有一个访问是写。

2. **Happens-Before关系**：如果一个动作 happens-before 另一个动作，则第一个对第二个可见，且第一个排在第二个之前。必须强调的是，两个动作之间存在 happens-before 关系并不意味着这些动作在 Java 中必须以这种顺序发生。 happens-before 关系主要用于强调两个有冲突的动作之间的顺序，以及定义数据争用的发生时机。

当程序包含两个没有被 happens-before 关系排序的冲突访问时，就称存在数据争用。

**顺序一致性（Sequential Consistency）**：在顺序一致的执行过程中，所有动作（如读和写）间存在一个全序关系，与程序的顺序一致。

一个程序是正确同步的当前仅当所有顺序一致的执行过程中都不存在数据争用。

在对象的构造器里为该对象的 final 字段赋值。不要将正在创建过程中的对象引用写到一个其它线程可以看到的地方，这会让其它线程在构造器尚未执行结束时就能访问该对象。如果遵循这个规则，当该对象被其它线程看到时，这些线程总是能看到该对象 final 字段的正确值。且这些 final 字段所引用的任意对象或数组的中的内容，至少是和 final 字段一样的新。

内存模型的一个高级、非正式的概述显示其是一组规则，规定了一个线程的写操作何时会对另一个线程可见。

## 2.定义

**共享变量/堆内存**：能够在线程间共享的内存。所有实例字段，静态字段及数组元素都存储在堆内存中。方法中的局部变量永远不会在线程间共享且不会被内存模型影响。

**线程间的动作**：由某一线程执行，能被另一线程探测或直接影响的动作（action）。包括共享变量的读写以及同步动作，如lock或unlock某个管程，读写某个volatile变量或启动一个线程。

**程序顺序**：在所有由线程t执行的线程间动作中，t的程序顺序是一个全序，反映出的是根据t的线程内语义，这些动作的执行顺序。

**线程内语义**：是单线程程序的标准语义，基于某个线程内读动作能看到的值，可以完整预测这个线程的行为。线程内语义决定某个线程孤立的执行过程。

**同步动作**：包括lock、unlock、读写volatile变量、用于启动线程的动作以及用于探测线程是否结束的动作。

**同步顺序**：一次执行过程中所有同步动作上的全序关系。

## 3.Java内存模型的正式规范

### 3.1 动作与执行过程

**动作** 动作a 是通过元组<t, k, v, u>来描述的，其中：

t - 执行该动作的线程

k - 动作的类型：volatile read，volatile write，（非volatile）read，（非 volatile）写，lock，unlock，特殊的同步动作，外部动作以及线程分散（ thread divergence）动作。volatile read，volatile write，lock和unlock都是同步动作，特殊的同步动作有诸如启动一个线程，线程中由编译器生成的第一个或最后一个动作，以及探测某个线程是否终止的动作。

v - 动作中涉及到的变量或管程

u - 该动作的任意一个唯一标识符